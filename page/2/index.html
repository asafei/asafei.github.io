<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>afei_ask</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="afei_ask">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="afei_ask">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="afei_ask">
  
    <link rel="alternate" href="/atom.xml" title="afei_ask" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">afei_ask</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-es6引入css" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/24/es6引入css/" class="article-date">
  <time datetime="2019-12-24T14:26:40.000Z" itemprop="datePublished">2019-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/24/es6引入css/">es6引入css</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>假设我们有一个名为<code>style.css</code>的css文件</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.default</span> &#123;</span><br><span class="line">    <span class="attribute">cursor</span>:null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.drag</span> &#123;</span><br><span class="line">    <span class="attribute">cursor</span>:move;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.rotate</span> &#123;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="built_in">url</span>(<span class="string">'../../assets/mouse/closedhand.cur'</span>) <span class="number">8</span> <span class="number">8</span>, default;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在其它js文件中如何引入并使用这个css文件呢，总不能一直只使用js来编写吧</p>
<p>假设我们在<code>EventManager.js</code>文件中要使用，有两种方式引入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./style/style.css'</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'./style/style.css'</span>);</span><br></pre></td></tr></table></figure>
<p>然后在代码中就可以直接使用了，如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">this</span>._dom.className=<span class="string">'rotate'</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">this</span>._dom.className=<span class="string">'drag'</span>;</span><br></pre></td></tr></table></figure>
<p>此时，css的效果就出来了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/24/es6引入css/" data-id="ck8iwvpz0001anso1tq3klpkj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-drawArrays和drawElements" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/24/drawArrays和drawElements/" class="article-date">
  <time datetime="2019-12-24T14:25:29.000Z" itemprop="datePublished">2019-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/24/drawArrays和drawElements/">drawArrays和drawElements</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在使用<code>drawArrays</code>时，我们通常是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bufferPosition = <span class="keyword">this</span>.gl.createBuffer();</span><br><span class="line">gl.bindBuffer(<span class="keyword">this</span>.gl.ARRAY_BUFFER, bufferPosition);</span><br><span class="line">gl.bufferData(<span class="keyword">this</span>.gl.ARRAY_BUFFER,<span class="keyword">new</span> <span class="built_in">Float32Array</span>(positions),<span class="keyword">this</span>.gl.STATIC_DRAW);</span><br></pre></td></tr></table></figure>
<p>然后再绑定vao时，指定一下数据就可以了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gl.enableVertexAttribArray(positionLocation);</span><br><span class="line">gl.vertexAttribPointer(positionLocation, size, type, normalize, stride, offset);</span><br></pre></td></tr></table></figure>
<p>这里说明一下：<code>ARRAY_BUFFER</code>绑定的数据属于全局状态。</p>
<p>而使用<code>drawElements</code>时，通常配合绑定<code>ARRAY_BUFFER</code>，还需要创建索引buffer</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建索引</span></span><br><span class="line"><span class="keyword">const</span> indexBuffer = gl.createBuffer();</span><br><span class="line">gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);</span><br><span class="line"><span class="keyword">const</span> indices = <span class="keyword">this</span>.earth.getFillIndices(<span class="number">64</span>,<span class="number">64</span>);</span><br><span class="line">gl.bufferData(</span><br><span class="line">    gl.ELEMENT_ARRAY_BUFFER,</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(indices),</span><br><span class="line">	gl.STATIC_DRAW</span><br><span class="line">);</span><br><span class="line"><span class="keyword">const</span> indexCount=indices.length;</span><br></pre></td></tr></table></figure>
<p>这里的<code>ELEMENT_ARRAY_BUFFER</code>是当前定点数组的一部分</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/24/drawArrays和drawElements/" data-id="ck8iwvpyy0018nso10riencoy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webgl/">webgl</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-webpack的使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/24/webpack的使用/" class="article-date">
  <time datetime="2019-12-24T14:22:38.000Z" itemprop="datePublished">2019-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/24/webpack的使用/">webpack的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、工程初始化"><a href="#一、工程初始化" class="headerlink" title="一、工程初始化"></a>一、工程初始化</h3><h4 id="1-1-入门"><a href="#1-1-入门" class="headerlink" title="1.1 入门"></a>1.1 入门</h4><ul>
<li><p>创建目录catirl</p>
</li>
<li><p>进入目录，执行初始化</p>
</li>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd catirl</span><br><span class="line">npm init -y</span><br><span class="line">npm install webpack webpack-cli --save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建源文件夹，并添加文件index.js</p>
</li>
<li><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">catirl</span><br><span class="line">  |- package.json</span><br><span class="line">+ |- index.html</span><br><span class="line">+ |- <span class="regexp">/src</span></span><br><span class="line"><span class="regexp">+   |- index.js</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注意：</strong>此时我们在<code>package.json</code>中保留<code>&quot;main&quot;: &quot;index.js&quot;</code>即可，没有必要改为<code>&quot;private&quot;: true</code>，保留的好处是，我们可以随时调试源代码，但是这样的不支持源代码中带有<code>import</code>和<code>export</code>语法 。</p>
<h4 id="1-2-支持import语法"><a href="#1-2-支持import语法" class="headerlink" title="1.2 支持import语法"></a>1.2 支持import语法</h4><p>为了支持<code>import</code>和<code>export</code>语法 ,webpack可以做转，在<code>package.json</code>文件，修改如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+   <span class="string">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">-   <span class="string">"main"</span>: <span class="string">"index.js"</span>,</span><br></pre></td></tr></table></figure>
<p>然后创建一个dist的目录，将<code>index.html</code>移动进去，并执行命令</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure>
<p>此时会将我们的脚本作为<a href="https://www.webpackjs.com/concepts/entry-points" target="_blank" rel="noopener">入口起点</a>，然后 <a href="https://www.webpackjs.com/concepts/output" target="_blank" rel="noopener">输出</a> 为 <code>main.js</code>，将<code>main.js</code>引入<code>index.html</code>就可以继续访问页面了。</p>
<p>通过npm进行打包，在<code>package.json</code>中补充</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"webpack"</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>就可以使用npm命令进行构建了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>
<h4 id="1-3-进一步定制webpack"><a href="#1-3-进一步定制webpack" class="headerlink" title="1.3 进一步定制webpack"></a>1.3 进一步定制webpack</h4><p>以上使用的都是默认的webpack的配置，如何定制呢，比如修改源文件入口文件、输出文件路径、输出文件名称，这时候就得配置<code>webpack.config.js</code>文件了。</p>
<p>新建<code>webpack.config.js</code>文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,    <span class="comment">//入口文件</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,    <span class="comment">//输出文件名称</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)<span class="comment">//输出文件路径</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>还有很多更复杂的配置，以后再讲</p>
<h4 id="1-4-可调试源码"><a href="#1-4-可调试源码" class="headerlink" title="1.4 可调试源码"></a>1.4 可调试源码</h4><p>此时碰到一个问题，打包出来的 <code>main.js</code>或 <code>bundle.js</code>是压缩过的代码，很难调试，这时候怎么办呢？<a href="https://www.jb51.net/article/150357.htm" target="_blank" rel="noopener">参考</a></p>
<p>此时就需要配置<code>webpack.config.js</code>了，在里面添加</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line"> devtool: <span class="string">'source-map'</span>,</span><br><span class="line"> entry:<span class="string">""</span>,</span><br><span class="line"> output: &#123;</span><br><span class="line"> &#125;</span><br><span class="line"> ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次执行<code>npm run build</code>就可以看到，生成的文件多了一个<code>bundle.js.map</code>文件,</p>
<p>有了它，就可以调试源码的页面了。</p>
<p>但是这样还不是很方便，在编写代码过程中，我们往往需要实时热更新加载。这该怎么办呢？</p>
<h4 id="1-5-热更新加载"><a href="#1-5-热更新加载" class="headerlink" title="1.5 热更新加载"></a>1.5 热更新加载</h4><p><a href="https://blog.csdn.net/a2013126370/article/details/88249664" target="_blank" rel="noopener">参考</a></p>
<p>首先需要一个本地web服务器，可以使用<code>webpack-dev-server</code>，安装该模块，并启动</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server</span><br><span class="line">npx webpack-dev-server</span><br></pre></td></tr></table></figure>
<p>这样就启动了，打开浏览器输入<a href="http://localhost:8080/就可以访问当前目录了" target="_blank" rel="noopener">http://localhost:8080/就可以访问当前目录了</a></p>
<p>当然，我们可以定制启动的路径，端口号等。</p>
<p>在<code>webpack.config.js</code>中添加：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;<span class="comment">//开发服务器的配置</span></span><br><span class="line">    <span class="comment">//端口号配置，默认为8080</span></span><br><span class="line">    port: <span class="number">3000</span>,</span><br><span class="line">    <span class="comment">//进度条</span></span><br><span class="line">    progress: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//指定打开浏览器显示的目录，默认为根目录（项目目录）</span></span><br><span class="line">    contentBase: <span class="string">'./dist'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候就可以通过输入<a href="http://localhost:3030/" target="_blank" rel="noopener">http://localhost:3030/</a> 直接访问<code>dist</code>根目录了，</p>
<p>此时我们在源码中直接修改代码，就可以在页面中实时更新了。</p>
<p><strong>疑问</strong></p>
<p>这里我有个疑问，如果之前我没有构建<code>bundle.js</code>或<code>bundle.js.map</code>文件，该server还能继续使用吗，我在<code>dist</code>文件夹下删除其余的文件，启动server，照样可以看到内容，奇怪。</p>
<p>然后我将html文件中对<code>bundle.js</code>的引用给注销掉，再次启动server就不行了，说明server自动构建了临时<code>bundle.js</code>了。这个构建规则遵从之前的打包配置规则。验证了一下，确实如此。</p>
<p>在<code>webpack.config.js</code>中将<code>bundle.js</code>名字改为<code>main.js</code>，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    <span class="comment">// filename: 'bundle.js',</span></span><br><span class="line">    filename: <span class="string">'main.js'</span>, </span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>再次启动server，页面就不正常显示了。但是在浏览器中输入<a href="http://localhost:3030/main.js，是可以看到代码内容的，说明web服务器中生成了`main.js`文件。" target="_blank" rel="noopener">http://localhost:3030/main.js，是可以看到代码内容的，说明web服务器中生成了`main.js`文件。</a></p>
<p><strong>结论：</strong>说明通过server启动访问的页面，优先访问web服务器内部生成的js文件。</p>
<p>如何让这个html文件中对js文件的引用也自动化起来呢，不至于这么摸不着头脑。</p>
<h4 id="1-6-通过模版html自动配置js文件"><a href="#1-6-通过模版html自动配置js文件" class="headerlink" title="1.6 通过模版html自动配置js文件"></a>1.6 通过模版html自动配置js文件</h4><p>使用<code>html-webpack-plugin</code>插件</p>
<p>首先安装该插件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin</span><br></pre></td></tr></table></figure>
<p>然后在<code>webpack.config.js</code>文件中配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入</span></span><br><span class="line"><span class="keyword">let</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">...</span><br><span class="line"> plugins: [ <span class="comment">//数组：放着所有的webpack插件</span></span><br><span class="line"> 	<span class="comment">// 配置</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./dist/template.html'</span>,</span><br><span class="line">      filename: <span class="string">'./dist/index.html'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中template是模版路径，<code>template.html</code>是模版内容，内容为</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Catirl<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>而<code>filename</code>属性的意思就是所生成HTML文件名，内容只是比<code>template</code>所指的HTML文件多引入你之前在<code>output-filename</code>中输出的js文件。</p>
<p><strong>注意：</strong> 通过server生成的html和js文件都没有保存在本地。</p>
<p>至此就完成了热加载的配置工作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/24/webpack的使用/" data-id="ck8iwvpzf001znso1pbpuweio" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/">webpack</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-坐标参考" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/24/坐标参考/" class="article-date">
  <time datetime="2019-12-24T14:08:13.000Z" itemprop="datePublished">2019-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/24/坐标参考/">坐标参考</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近在用webgl手撕一个三维GIS引擎，引擎内部使用4326的参考系，切片使用的3857的<a href="http://cache1.arcgisonline.cn/arcgis/rest/services/ChinaOnlineCommunityENG/MapServer" target="_blank" rel="noopener">数据源</a>，出现的效果就是经度正常，但是纬度方向被压缩了，如下图所示。<br><img src="/2019/12/24/坐标参考/earth.png" title="earth"></p>
<p>这是一个可以预见的情况，但是也引出了一些长期困扰自己的问题，趁这次机会深入理清一下。</p>
<h4 id="一、Mercator投影"><a href="#一、Mercator投影" class="headerlink" title="一、Mercator投影"></a>一、Mercator投影</h4><p>mercator投影是一种”<a href="https://baike.baidu.com/item/等角正切圆柱投影" target="_blank" rel="noopener">等角正切圆柱投影</a>”，以地球为例，<strong>假设地球被围在一中空的圆柱里，其基准纬线与圆柱相切（赤道）接触，然后再假想地球中心有一盏灯，把球面上的图形投影到圆柱体上，再把圆柱体展开</strong>，这就是一幅选定基准纬线上的“墨卡托投影”绘制出的地图，如下图：</p>
<img src="/2019/12/24/坐标参考/mercator.jpg" title="mercator.jpg">
<p>当然，这是一个对于任何一个giser都知道的概念，在这里重点强调的一点是：<strong>墨卡托投影的对象不仅仅是正球，对椭球也一样通用</strong>。</p>
<p>更准确的来说，椭球才是标准对象。我们的地球是一种更接近与梨形的球体，如下</p>
<img src="/2019/12/24/坐标参考/realEarth.webp" title="realEarth.webp">
<p>每个地区高低不平，所以各个地区都会根据本区域特点，选取一个最适合本区域的椭球体作为参考了对象，往往一个地区的参考椭球体并不使用于另外一个区域。实际上，对于局部小区域，也可用会用圆锥切面投影，或是高斯-克吕格投影。</p>
<p>Mercator 投影坐标系统，全球范围尺度上其基准面可以是 <code>WGS 1984</code> ，</p>
<p><code>WGS 1984</code>定义如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GCS_WGS_1984</span><br><span class="line">WKID: <span class="number">4326</span> Authority: EPSG</span><br><span class="line">Angular Unit: Degree (<span class="number">0.0174532925199433</span>)</span><br><span class="line">Prime Meridian: Greenwich (<span class="number">0.0</span>)</span><br><span class="line">Datum: D_WGS_1984</span><br><span class="line">Spheroid: WGS_1984</span><br><span class="line">Semimajor Axis: <span class="number">6378137.0</span></span><br><span class="line">Semiminor Axis: <span class="number">6356752.314245179</span></span><br><span class="line">Inverse Flattening: <span class="number">298.257223563</span></span><br></pre></td></tr></table></figure>
<img src="/2019/12/24/坐标参考/wgs84.png" title="wgs84.png">
<p>墨卡托投影的“圆柱”特性，保证了南北（纬线）和东西（经线）都是平行直线，并且相互垂直。而且经线间隔是相同的，纬线间隔从标准纬线（此处是赤道，也可能是其他纬线）向两级逐渐增大。</p>
<p>既然是投影了，肯定会涉及到投影的换算，它的投影计算公式应该是椭球的投影公司如下：</p>
<ul>
<li>x、y是投影展开成平面后以赤道本初子午线交点为原点的平面坐标系的坐标</li>
<li>a 是椭球体长半轴，b是短半轴</li>
<li>L是经度（弧度制），B是纬度（弧度制）</li>
</ul>
<img src="/2019/12/24/坐标参考/mercatorProject.webp" title="mercatorProject.webp">
<h4 id="二、WebMercator投影"><a href="#二、WebMercator投影" class="headerlink" title="二、WebMercator投影"></a>二、WebMercator投影</h4><p> Web Mercator 坐标系使用的投影方法不是严格意义的墨卡托投影，而是一个被 EPSG（European Petroleum Survey Group）称为伪墨卡托的投影方法，这个伪墨卡托投影方法的大名是 Popular Visualization Pseudo Mercator，PVPM。</p>
<p>因为这个坐标系统是 Google Map 最先使用的，或者更确切地说，是Google 最先发明的。在投影过程中，将表示地球的参考椭球体近似的作为正球体处理（正球体半径 R = 椭球体半长轴 a）。这也是为什么在 ArcGIS 中我们经常看到这个坐标系叫 WGS 1984 Web Mercator (Auxiliary Sphere)。Auxiliary Sphere 就是在告知你，这个坐标在投影过程中，将椭球体近似为正球体做投影变换，虽然基准面是WGS 1984 椭球面。</p>
<img src="/2019/12/24/坐标参考/webMercatorProject.png" title="webMercatorProject.png">
<p>后来，Web Mercator 在 Web 地图领域被广泛使用，这个坐标系就名声大噪。尽管这个坐标系由于精度问题一度不被GIS专业人士接受，但最终 EPSG 还是给了 WKID:3857</p>
<h4 id="三、切片和切片原点"><a href="#三、切片和切片原点" class="headerlink" title="三、切片和切片原点"></a>三、切片和切片原点</h4><p>我们知道通过墨卡托投影后，x轴是经度投影的结果，经度区间是[-π，π]；y轴时纬度投影的结果，而纬度区间为[-π/2,π/2]。而我们的3857的切片服务，通常切片原点是[-2.0037508342787E7,2.0037508342787E7]。</p>
<img src="/2019/12/24/坐标参考/originCoord.png" title="originCoord.png">
<p>这就不好理解了，x轴是以赤道周长来算的，x轴的范围是[-2.0037508342787E7,2.0037508342787E7]可以计算出来，可是为啥y轴的的范围也是[-2.0037508342787E7,2.0037508342787E7]呢？另一个与此相光的问题是为什么在切片的每个级别上分辨率是一个值呢？常规理解应该是x轴一个分辨率，y轴一个分辨率的。并且由于切片是正方形，x轴的分辨率应该是y轴分辨率的2倍才对呀。</p>
<p>其实虽然纬度区间[-π/2,π/2]只是经度区间[-π，π]的二分之一，但是在投影后同一纬度上的经度属于等间距投影，但是纬度却是随着纬度的增加投影距离不断增大，直到纬度为90度时，投影点趋于无穷大。纬度上的距离区间应该远远大于经度区间才对，如下图</p>
<img src="/2019/12/24/坐标参考/infinity.png" title="infinity.png">
<p>此时有两点可以明确：</p>
<ul>
<li>同一纬度上，经度投影分布是均匀的，线性的</li>
<li>纬度的投影，随着纬度的增加，投影距离是不断增大，是非线性的。</li>
</ul>
<p>那么如何让纬度纬度线的区间分布也是均匀的呢？这场计算纬度线的投影距离公式是<code>y=f(φ)=R*tan(φ)</code>；有一个聪明的家伙模拟了一个近似函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">		-ln(tan(π/4 + abs(φ/2)))     φ&lt;0时</span><br><span class="line">y=g(φ)= +ln(tan(π/4 + abs(φ/2)))     φ=0时</span><br><span class="line">		+ln(tan(π/4 + abs(φ/2)))     φ&gt;0时</span><br></pre></td></tr></table></figure>
<p>这种投影算法使得赤道附近的纬线较密，极地附近的纬线较稀。极点被投影到无穷远，所以这种投影不适合在高纬度地区使用。Google Maps的选取的范围为 -π&lt;y&lt;π ，这样近似的有 -85°&lt;Φ&lt;85°。这也就得到了y轴上的取值区间和x轴上的取值区间一致，一张方形的世界地图就出来了。</p>
<p>这时就注意了，在做x轴的切片计算时，可以采用二分的方式直接计算，但是对于y轴切片的计算则不能使用二分了，因为y轴不是线性切片的，必须严格按照该界别切片提供的分辨率进行计算。这么做就将问题分离开了，可视化人员只需要按照既定的规则进行切片展示；制图人员可以自定义经纬度两个方向切片的计算方法（只需最终输出满足既定规则的切片即可）；</p>
<h3 id="四、像素坐标"><a href="#四、像素坐标" class="headerlink" title="四、像素坐标"></a>四、像素坐标</h3><p>提到分辨率，就需要解释像素坐标了。</p>
<p>分辨率表示一个像素代表的实际长度，可以同过分辨率和像素坐标来计算该像素点所在的实际位置。</p>
<p>将地球表面通过墨卡托投影到一个方形平面时，依据展示内容的精细度，这个方形平面可大可小。通常全球范围内就不需要展示特别精细的内容，只需要轮廓就可以，而在一个工业园区级别就需要将具体的厂房道路展示出来。这样最终精细度的提高，我们这张世界地图的尺寸就越来越大。</p>
<img src="/2019/12/24/坐标参考/level.png" title="level.png">
<p>不过好在，我们通常在精细化程度较高时，往往只需要看到很小的一块区域，为了切分的方便，一般切分方式都是以2的次幂来切分。这方面的内容此处不再赘述。只强调一点：<strong>既定的级别都有自己的分辨率，无论经度还是纬度都可以依据这个分辨率来准确的计算某一像素点的实际位置，而不必再考虑该图是如何将经度和纬度统一起来制图的</strong>。</p>
<p>地图学中一个重要的概念，就是比例尺，即<strong>地图上的一厘米代表着实际上的多少厘米</strong>；到了web地图中我们把比例尺转换成另一个概念，分辨率（Resolution），即<strong>图上一像素代表实际多少米</strong>。</p>
<p>假设地图的坐标单位是米，整张地图的dpi为96，当前地图在赤道处的比例尺为1:125000000（即图上1米等于实地125000000米），1英寸=2.54厘米； 1英寸=96像素。那么计算可得地图赤道上1像素代表实地距离是 125000000*0.0254/96 = 33072.9166666667米。为什么要强调某一条纬度线（上述例子为赤道）的比例尺？因为根据墨卡托投影的特性，同一张地图中不同纬度线的比例尺是变化的，越靠近两极，图上1米相当于实地的距离越小。</p>
<p>参考：</p>
<p><a href="https://www.jianshu.com/p/778fc3e9f889" target="_blank" rel="noopener"><a href="https://www.jianshu.com/p/778fc3e9f889" target="_blank" rel="noopener">https://www.jianshu.com/p/778fc3e9f889</a></a></p>
<p><a href="https://blog.csdn.net/mr_jianrong/article/details/72625811" target="_blank" rel="noopener"><a href="https://blog.csdn.net/mr_jianrong/article/details/72625811" target="_blank" rel="noopener">https://blog.csdn.net/mr_jianrong/article/details/72625811</a></a></p>
<p><a href="https://blog.csdn.net/kikitamoon/article/details/46124935" target="_blank" rel="noopener"><a href="https://blog.csdn.net/kikitamoon/article/details/46124935" target="_blank" rel="noopener">https://blog.csdn.net/kikitamoon/article/details/46124935</a></a></p>
<p><a href="https://www.maptiler.com/google-maps-coordinates-tile-bounds-projection/" target="_blank" rel="noopener"><a href="https://www.maptiler.com/google-maps-coordinates-tile-bounds-projection/" target="_blank" rel="noopener">https://www.maptiler.com/google-maps-coordinates-tile-bounds-projection/</a></a></p>
<p><a href="https://blog.csdn.net/qq_35732147/article/details/83856513" target="_blank" rel="noopener"><a href="https://blog.csdn.net/qq_35732147/article/details/83856513" target="_blank" rel="noopener">https://blog.csdn.net/qq_35732147/article/details/83856513</a></a></p>
<p><a href="[https://baike.baidu.com/item/%E5%A2%A8%E5%8D%A1%E6%89%98%E6%8A%95%E5%BD%B1/5477927?fr=kg_qa](https://baike.baidu.com/item/墨卡托投影/5477927?fr=kg_qa">https://baike.baidu.com/item/%E5%A2%A8%E5%8D%A1%E6%89%98%E6%8A%95%E5%BD%B1/5477927?fr=kg_qa</a>)</p>
<p><a href="https://www.maptiler.com/google-maps-coordinates-tile-bounds-projection/" target="_blank" rel="noopener"><a href="https://www.maptiler.com/google-maps-coordinates-tile-bounds-projection/" target="_blank" rel="noopener">https://www.maptiler.com/google-maps-coordinates-tile-bounds-projection/</a></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/24/坐标参考/" data-id="ck8iwvq0r003jnso1s132per5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/GIS/">GIS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-WebGL绑定多纹理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/24/WebGL绑定多纹理/" class="article-date">
  <time datetime="2019-12-24T14:03:48.000Z" itemprop="datePublished">2019-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/24/WebGL绑定多纹理/">WebGL绑定多纹理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们的场景时实时渲染网络切片地图栅格数据。如果每次在渲染阶段进行数据的绑定，必定会降低帧率，什么卡顿。该如何优化呢</p>
<h3 id="一、思考"><a href="#一、思考" class="headerlink" title="一、思考"></a>一、思考</h3><p>对于非图片数据，我们的处理方式是：</p>
<ul>
<li>将各attribute数据绑定到vbo中；</li>
<li>将各vbos绑定给指定的vao中；</li>
<li>绘制时，切换vao即可。</li>
</ul>
<p>但是这个方式对绘制大量图片并不适用，原因是webgl中可绑定的纹理数量一定。这就导致对于有限树数量的纹理单元（textureUnit）我们必须要重复使用。</p>
<p>如何破解这个问题呢？</p>
<p>虽然可绑定的纹理单元数量有限，但是我们可创建的纹理却不受限制。</p>
<p>这样我们就可以继续将各vbo绑定给vao，然后在绘制时，实时将已经创建好纹理绑定给指定的纹理单元即可。</p>
<h3 id="二、方案"><a href="#二、方案" class="headerlink" title="二、方案"></a>二、方案</h3><ul>
<li>计算要渲染切片的position、textureCoord、index等数据</li>
<li>创建各个attribute的buffer</li>
<li>创建一个空纹理对象texture，可以是纯色</li>
<li>将各buffers绑定给vao，并且将空纹理texture与该vao关联起来</li>
<li>异步请求img的实际数据，然后更新纹理的真实数据，并给texture标记需update</li>
<li>绘制时，若texture的update为false，则直接绑定空纹理数据绘制；若update为true，则重新绑定纹理数据，进行绘制</li>
</ul>
<h3 id="三、其它"><a href="#三、其它" class="headerlink" title="三、其它"></a>三、其它</h3><p>需要注意：</p>
<ul>
<li>请求切片可以放在子线程中执行；</li>
<li>这个频繁切换的纹理，要使用可变纹理的方式</li>
</ul>
<h3 id="四、创建空纹理的代码"><a href="#四、创建空纹理的代码" class="headerlink" title="四、创建空纹理的代码"></a>四、创建空纹理的代码</h3><p>对于网络图片，首先需要先把图片数据下载下来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// creates a texture info &#123; width: w, height: h, texture: tex &#125;</span></span><br><span class="line"><span class="comment">// The texture will start with 1x1 pixels and be updated</span></span><br><span class="line"><span class="comment">// when the image has loaded</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImageAndCreateTextureInfo</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//创建纹理对像，默认设置填充为蓝色</span></span><br><span class="line">  <span class="keyword">var</span> tex = gl.createTexture();</span><br><span class="line">  gl.bindTexture(gl.TEXTURE_2D, tex);</span><br><span class="line">  <span class="comment">// Fill the texture with a 1x1 blue pixel.</span></span><br><span class="line">  gl.texImage2D(gl.TEXTURE_2D, <span class="number">0</span>, gl.RGBA, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, gl.RGBA, gl.UNSIGNED_BYTE,</span><br><span class="line">                <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>, <span class="number">255</span>]));</span><br><span class="line"> </span><br><span class="line">  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);</span><br><span class="line">  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">var</span> textureInfo = &#123;</span><br><span class="line">    width: <span class="number">1</span>,   <span class="comment">// we don't know the size until it loads</span></span><br><span class="line">    height: <span class="number">1</span>,</span><br><span class="line">    texture: tex,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">  img.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    textureInfo.width = img.width;</span><br><span class="line">    textureInfo.height = img.height;</span><br><span class="line"> </span><br><span class="line">    gl.bindTexture(gl.TEXTURE_2D, textureInfo.texture);</span><br><span class="line">    gl.texImage2D(gl.TEXTURE_2D, <span class="number">0</span>, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);</span><br><span class="line">    gl.generateMipmap(gl.TEXTURE_2D);</span><br><span class="line">  &#125;);</span><br><span class="line">  img.src = url;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> textureInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>思路1</p>
<p>先将顶点坐标、纹理坐标、纹理预处理好，可以直接绘制。并且绑定给vao。在绘制时，默认绘制vao，直到真实纹理加载完成，直接再次绑定新的纹理即可。</p>
</li>
</ul>
<p>课外：<a href="https://webgl2fundamentals.org/webgl/lessons/webgl-texture-units.html" target="_blank" rel="noopener"><a href="https://webgl2fundamentals.org/webgl/lessons/webgl-texture-units.html" target="_blank" rel="noopener">https://webgl2fundamentals.org/webgl/lessons/webgl-texture-units.html</a></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/24/WebGL绑定多纹理/" data-id="ck8iwvpyk000lnso1iguhppua" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webgl/">webgl</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/24/hello-world/" class="article-date">
  <time datetime="2019-12-24T14:02:24.849Z" itemprop="datePublished">2019-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/24/hello-world/">Hello again</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h3><p>作为程序员的悲哀，大家以我为鉴。</p>
<h3 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3><p>使用vim莫名的创建一个“～”的文件夹，就想着删除它，执行代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm ~</span><br></pre></td></tr></table></figure></p>
<p>发现居然删不了，果断换成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~</span><br></pre></td></tr></table></figure></p>
<p>然后就是输入权限密码，然后就悲剧了，事情的结果是我的整个根目录几乎被删除殆尽。</p>
<h3 id="亡羊补牢"><a href="#亡羊补牢" class="headerlink" title="亡羊补牢"></a>亡羊补牢</h3><p>在mac中 “～”表示home目录，如果直接删除名为“～”的目录，相当于删除整个home目录下的所有文件（这也是为什么要管理员权限的原因），几乎无论这个“～”在什么位置都不要直接删除它。<br>如果非要删除，该怎么办呢？答案是使用绝对路径，比如我将“～”创建在了<em>“/home/afei/Desktop/”</em>下，那么执行下列命令即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /home/afei/Desktop/～</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/24/hello-world/" data-id="ck8iwvpz3001fnso1hl4jfalt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-WebGL跨域图片" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/24/WebGL跨域图片/" class="article-date">
  <time datetime="2019-12-24T13:56:35.000Z" itemprop="datePublished">2019-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/24/WebGL跨域图片/">WebGL跨域图片</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h5 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h5><p>通常我们加载图片时使用这种方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url=<span class="string">'https://t6.tianditu.gov.cn/DataServer?T=img_w&amp;x=2&amp;y=1&amp;l=3&amp;tk=8971e4c7b3640d506c2dc111221af6a0'</span>;<span class="comment">//天地图的一张切片</span></span><br><span class="line"><span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">image.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//拿到image，做纹理数据</span></span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line">image.src=url;</span><br></pre></td></tr></table></figure>
<p>但是当图片为跨域图像时，就出现问题了。常规浏览器报错</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to image at <span class="string">'https://t6.tianditu.gov.cn/DataServer?T=img_w&amp;x=2&amp;y=1&amp;l=3&amp;tk=8971e4c7b3640d506c2dc111221af6a0'</span> <span class="keyword">from</span> origin <span class="string">'http://localhost:3030'</span> has been blocked by CORS policy: The <span class="string">'Access-Control-Allow-Origin'</span> header has a value <span class="string">'https://map.tianditu.gov.cn'</span> that is not equal to the supplied origin.</span><br></pre></td></tr></table></figure>
<p>接下来将浏览器设置为可跨域模式（方法自行百度），此时控制台是不报错了，但是也没有任何图像展示出来。</p>
<p>？？？这他娘的不是说好的img标签允许跨域的吗？</p>
<h5 id="二、探索"><a href="#二、探索" class="headerlink" title="二、探索"></a>二、探索</h5><p>通过添加错误的监听，可以看到image没有进入到<code>load</code>回调中，而是进入到了<code>error</code>的回调中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">image.addEventListener(<span class="string">'error'</span>, ()=&gt;&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">"error"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>直接使用<code>&lt;img src=&quot;private.jpg&quot;&gt;</code>是没什么问题的，因为图像尽管被浏览器显示， 便签对象并不能获取图像的内部数据。而Webgl使用的就是image的内部数据，就获取不到了。</p>
<p>有什么方法可以获取到跨域图像内部的数据呢？</p>
<h5 id="三、解决方式"><a href="#三、解决方式" class="headerlink" title="三、解决方式"></a>三、解决方式</h5><p>对于访问跨域资源必须同时满足两方面的许可：</p>
<ul>
<li>1 跨域站点允许跨域访问（需要服务器设置）</li>
<li>2 本地可以使用跨域的资源的内容（例如设置浏览器可跨域访问）</li>
</ul>
<p>下面所讲的都只是解决2的问题。</p>
<h6 id="3-1-设置crossOrigin"><a href="#3-1-设置crossOrigin" class="headerlink" title="3.1 设置crossOrigin"></a>3.1 设置crossOrigin</h6><p>最简单的方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> url=<span class="string">''</span>;</span><br><span class="line"><span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">image.crossOrigin = <span class="string">"anonymous"</span>; <span class="comment">//允许</span></span><br><span class="line">image.addEventListener(<span class="string">'load'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//拿到image，做纹理数据</span></span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line">image.src=url;</span><br></pre></td></tr></table></figure>
<p>crossOrigin的值有三个可选择：</p>
<ul>
<li>undefined：默认值，表示不需要请求许可；</li>
<li>anonymous：表示请求许可，但是不发送任何信息；</li>
<li>use-credentials：表示发送cookies和其它可能需要的信息，服务器会根据这些信息决定是否授予许可。</li>
</ul>
<p><strong>注意：设置为其他任意值则相当于 “anonymous”</strong></p>
<p>设置完<code>crossOrigin</code>属性后，浏览器从服务器请求图像时，对于不同域名，会请求CROS许可。由于请求需求需要2个http请求，资源消耗多一些。所以同域的不需要设置请求许可，只需对跨域的资源的img标签或canvas2d设置<code>crossDomain</code>属性，这样就不会使请求变慢了。</p>
<p>可以添加这个一个适配函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestCORSIfNotSameOrigin</span>(<span class="params">img, url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">new</span> URL(url)).origin !== <span class="built_in">window</span>.location.origin) &#123;</span><br><span class="line">    img.crossOrigin = <span class="string">""</span>;<span class="comment">//相当于anonymous</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="3-2-使用canvas"><a href="#3-2-使用canvas" class="headerlink" title="3.2 使用canvas"></a>3.2 使用canvas</h6><p>第二种方法就是先将图片绘制在画布上，然后读取画布上的数据。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:none;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"source"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">src</span>=<span class="string">"https://mdn.mozillademos.org/files/5397/rhino.jpg"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">width</span>=<span class="string">"300"</span> <span class="attr">height</span>=<span class="string">"227"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas=<span class="built_in">document</span>.getElementById(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">const</span> ctx=canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">const</span> image = <span class="built_in">document</span>.getElementById(<span class="string">'source'</span>);</span><br><span class="line">image.addEventListener(<span class="string">'load'</span>, e =&gt; &#123;</span><br><span class="line">  	ctx.drawImage(image, <span class="number">33</span>, <span class="number">71</span>, <span class="number">104</span>, <span class="number">124</span>, <span class="number">21</span>, <span class="number">20</span>, <span class="number">87</span>, <span class="number">104</span>);</span><br><span class="line">    <span class="comment">//ctx.drawImage(someImg, 0, 0);</span></span><br><span class="line">	<span class="comment">//const data = ctx.getImageData(0, 0, width, heigh);</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在WebGL中 <code>gl.readPixels</code> 和 <code>ctx.getImageData</code> 是相似的， 所以你可能以为把这个接口封闭就好了，但事实是即使不能直接获取像素值， 也可以创建一个基于图像颜色的着色器，虽然效率低但是可以等同于获取到了图像信息。</p>
<p>参考：</p>
<p><a href="https://webgl2fundamentals.org/webgl/lessons/webgl-cors-permission.html" target="_blank" rel="noopener"><a href="https://webgl2fundamentals.org/webgl/lessons/webgl-cors-permission.html" target="_blank" rel="noopener">https://webgl2fundamentals.org/webgl/lessons/webgl-cors-permission.html</a></a></p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage" target="_blank" rel="noopener"><a href="https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage</a></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/12/24/WebGL跨域图片/" data-id="ck8iwvpym000nnso15tpdacjb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webgl/">webgl</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ES7新特性" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/12/ES7新特性/" class="article-date">
  <time datetime="2019-03-12T03:52:35.000Z" itemprop="datePublished">2019-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/12/ES7新特性/">ES7新特性</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="一、ES7新特性"><a href="#一、ES7新特性" class="headerlink" title="一、ES7新特性"></a>一、ES7新特性</h4><p>常用的更新有两个：</p>
<ul>
<li>求幂运算符</li>
<li>数组的includes方法</li>
</ul>
<h5 id="1-1-求幂运算符（-）"><a href="#1-1-求幂运算符（-）" class="headerlink" title="1.1 求幂运算符（**）"></a>1.1 求幂运算符（**）</h5><p>基本使用方式，求5的2次幂</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>**<span class="number">2</span>  <span class="comment">//25</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">5</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>复合使用的话依然遵循从右向左的优先级</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>**<span class="number">4</span>**<span class="number">2</span></span><br><span class="line"><span class="comment">//灯架</span></span><br><span class="line"><span class="number">2</span>**(<span class="number">4</span>**<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h5 id="1-2-Array-prototype-includes-方法"><a href="#1-2-Array-prototype-includes-方法" class="headerlink" title="1.2 Array.prototype.includes()方法"></a>1.2 Array.prototype.includes()方法</h5><p><code>includes()</code>查找一个值在不在数组里，若在，则返回<code>true</code>，反之返回<code>false</code>。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].includes(<span class="string">'a'</span>)     <span class="comment">// true</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].includes(<span class="string">'d'</span>)     <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>include也可以接收两个参数，要搜索的值和起始索引。当第二个参数被传入时，该方法会从索引处开始往后搜索（默认索引值为0）。若搜索值在数组中存在则返回<code>true</code>，否则返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>].includes(<span class="string">'b'</span>)         <span class="comment">// true</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>].includes(<span class="string">'b'</span>, <span class="number">1</span>)      <span class="comment">// true</span></span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>].includes(<span class="string">'b'</span>, <span class="number">2</span>)      <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>Includes方法与indexof的区别在于：</p>
<ul>
<li><p>includes更轻便，无需再判断返回值是否大于-1；</p>
</li>
<li><p>includes可以判断Nan，而indexof不能判断Nan</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">let</span> demo = [<span class="number">1</span>, <span class="literal">NaN</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&gt; </span><br><span class="line">&gt; demo.indexOf(<span class="literal">NaN</span>)        <span class="comment">//-1</span></span><br><span class="line">&gt; demo.includes(<span class="literal">NaN</span>)       <span class="comment">//true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>Include 对于+0和-0按相等处理的</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; [<span class="number">1</span>, +<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>].includes(<span class="number">-0</span>)    <span class="comment">//true</span></span><br><span class="line">&gt; [<span class="number">1</span>, +<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>].indexOf(<span class="number">-0</span>)     <span class="comment">//1</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h4 id="二、ES8新特性"><a href="#二、ES8新特性" class="headerlink" title="二、ES8新特性"></a>二、ES8新特性</h4><h5 id="2-1-async-await"><a href="#2-1-async-await" class="headerlink" title="2.1 async/await"></a>2.1 async/await</h5><p>传统的JavaScript中，对于异步的处理通常是通过回调函数处理的，但是一旦出现回调函数的嵌套，就很容易陷入回调地狱（callback hell）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$http.jsonp(<span class="string">'/login'</span>, (res) =&gt; &#123;</span><br><span class="line">  <span class="keyword">this</span>.$http.jsonp(<span class="string">'/getInfo'</span>, (info) =&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>一种改进方式是使用promise，通过then方法将回调嵌套改为了链式的,尽管如此，当请求任务过多时一堆then也会造成语义的难以理解。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ar promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">this</span>.login(resolve)</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.getInfo())</span><br><span class="line">.catch(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="built_in">console</span>.log(<span class="string">"Error"</span>) &#125;)</span><br></pre></td></tr></table></figure>
<p>另一种异步机制时使用Generator函数，它通过* 、yield和next的来执行分段操作。Generator 函数是分段执行的，yield表达式是暂停执行的标记，而next方法可以恢复执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br><span class="line"></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line">hw.next()</span><br><span class="line"><span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>虽然Generator将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。此时，我们便希望能出现一种能自动执行Generator函数的方法。我们的主角来了：async/await。</p>
<p>ES8引入了async函数，使得异步操作变得更加方便。简单说来，它就是Generator函数的语法糖。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result1 = <span class="keyword">await</span> <span class="keyword">this</span>.login()</span><br><span class="line">  <span class="keyword">const</span> result2 = <span class="keyword">await</span> <span class="keyword">this</span>.getInfo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理单个异步结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> otherAsyncFunc();</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>顺序处理多个异步结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result1 = <span class="keyword">await</span> otherAsyncFunc1();</span><br><span class="line">  <span class="built_in">console</span>.log(result1);</span><br><span class="line">  <span class="keyword">const</span> result2 = <span class="keyword">await</span> otherAsyncFunc2();</span><br><span class="line">  <span class="built_in">console</span>.log(result2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并行处理多个异步结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [result1, result2] = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">    otherAsyncFunc1(),</span><br><span class="line">    otherAsyncFunc2()</span><br><span class="line">  ]);</span><br><span class="line">  <span class="built_in">console</span>.log(result1, result2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理错误</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> otherAsyncFunc();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-2-Object-entries-和Object-values"><a href="#2-2-Object-entries-和Object-values" class="headerlink" title="2.2 Object.entries()和Object.values()"></a>2.2 Object.entries()和Object.values()</h5><h6 id="2-2-1Object-entries"><a href="#2-2-1Object-entries" class="headerlink" title="2.2.1Object.entries()"></a>2.2.1Object.entries()</h6><p>如果一个对象是具有键值对的数据结构，则每一个键值对都将会编译成一个具有两个元素的数组，这些数组最终会放到一个数组中，返回一个二维数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.entries(&#123; <span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span> &#125;)    <span class="comment">//[['one', 1], ['two', 2]]</span></span><br><span class="line"><span class="built_in">Object</span>.entries([<span class="number">1</span>, <span class="number">2</span>])                <span class="comment">//[['0', 1], ['1', 2]]</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>键值对中，如果键的值是Symbol，编译时将会被忽略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.entries(&#123; [<span class="built_in">Symbol</span>()]: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span> &#125;)       <span class="comment">//[['two', 2]]</span></span><br></pre></td></tr></table></figure>
<p><code>Object.entries()</code>返回的数组的顺序与for-in循环保持一致，即如果对象的key值是数字，则返回值会对key值进行排序，返回的是排序后的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.entries(&#123; <span class="number">3</span>: <span class="string">'a'</span>, <span class="number">4</span>: <span class="string">'b'</span>, <span class="number">1</span>: <span class="string">'c'</span> &#125;)    <span class="comment">//[['1', 'c'], ['3', 'a'], ['4', 'b']]</span></span><br></pre></td></tr></table></figure>
<h6 id="2-2-2-Object-values"><a href="#2-2-2-Object-values" class="headerlink" title="2.2.2 Object.values()"></a>2.2.2 Object.values()</h6><p>它的工作原理跟<code>Object.entries()</code>很像，顾名思义，它只返回自己的键值对中属性的值。它返回的数组顺序，也跟<code>Object.entries()</code>保持一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(&#123; <span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span> &#125;)            <span class="comment">//[1, 2]</span></span><br><span class="line"><span class="built_in">Object</span>.values(&#123; <span class="number">3</span>: <span class="string">'a'</span>, <span class="number">4</span>: <span class="string">'b'</span>, <span class="number">1</span>: <span class="string">'c'</span> &#125;)    <span class="comment">//['c', 'a', 'b']</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-padStart和padEnd"><a href="#2-3-padStart和padEnd" class="headerlink" title="2.3 padStart和padEnd"></a>2.3 padStart和padEnd</h5><p>ES8提供了新的字符串方法-padStart和padEnd。<code>padStart</code>函数通过填充字符串的首部来保证字符串达到固定的长度，反之，<code>padEnd</code>是填充字符串的尾部来保证字符串的长度的。该方法提供了两个参数：字符串目标长度和填充字段，其中第二个参数可以不填，默认情况下使用空格填充。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Vue'</span>.padStart(<span class="number">10</span>)           <span class="comment">//'       Vue'</span></span><br><span class="line"><span class="string">'React'</span>.padStart(<span class="number">10</span>)         <span class="comment">//'     React'</span></span><br><span class="line"><span class="string">'JavaScript'</span>.padStart(<span class="number">10</span>)    <span class="comment">//'JavaScript'</span></span><br></pre></td></tr></table></figure>
<p>那么我们现在来看看第二个参数，我们可以指定字符串来代替空字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Vue'</span>.padStart(<span class="number">10</span>, <span class="string">'_*'</span>)           <span class="comment">//'_*_*_*_Vue'</span></span><br><span class="line"><span class="string">'React'</span>.padStart(<span class="number">10</span>, <span class="string">'Hello'</span>)      <span class="comment">//'HelloReact'</span></span><br><span class="line"><span class="string">'JavaScript'</span>.padStart(<span class="number">10</span>, <span class="string">'Hi'</span>)    <span class="comment">//'JavaScript'</span></span><br><span class="line"><span class="string">'JavaScript'</span>.padStart(<span class="number">8</span>, <span class="string">'Hi'</span>)     <span class="comment">//'JavaScript'</span></span><br></pre></td></tr></table></figure>
<p><code>padEnd</code>函数作用同<code>padStart</code>，只不过它是从字符串尾部做填充</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'Vue'</span>.padEnd(<span class="number">10</span>, <span class="string">'_*'</span>)           <span class="comment">//'Vue_*_*_*_'</span></span><br><span class="line"><span class="string">'React'</span>.padEnd(<span class="number">10</span>, <span class="string">'Hello'</span>)      <span class="comment">//'ReactHello'</span></span><br><span class="line"><span class="string">'JavaScript'</span>.padEnd(<span class="number">10</span>, <span class="string">'Hi'</span>)    <span class="comment">//'JavaScript'</span></span><br><span class="line"><span class="string">'JavaScript'</span>.padEnd(<span class="number">8</span>, <span class="string">'Hi'</span>)     <span class="comment">//'JavaScript'</span></span><br></pre></td></tr></table></figure>
<h5 id="2-4-Object-getOwnPropertyDescriptors"><a href="#2-4-Object-getOwnPropertyDescriptors" class="headerlink" title="2.4 Object.getOwnPropertyDescriptors()"></a>2.4 Object.getOwnPropertyDescriptors()</h5><p>略</p>
<h5 id="2-5-共享内存和原子（Shared-memory-and-atomics）"><a href="#2-5-共享内存和原子（Shared-memory-and-atomics）" class="headerlink" title="2.5 共享内存和原子（Shared memory and atomics）"></a>2.5 共享内存和原子（Shared memory and atomics）</h5><p>内存管理碰撞课程：<a href="https://segmentfault.com/a/1190000009878588" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009878588</a></p>
<p>图解 ArrayBuffers 和 SharedArrayBuffers：<a href="https://segmentfault.com/a/1190000009878632" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009878632</a></p>
<p>用 Atomics 避免 SharedArrayBuffers 竞争条件：<a href="https://segmentfault.com/a/1190000009878699" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009878699</a></p>
<p>参考：<a href="https://www.cnblogs.com/zhuanzhuanfe/p/7493433.html" target="_blank" rel="noopener"></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/12/ES7新特性/" data-id="ck8iwvpy10001nso1kxwrk1w8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-作用域绑定" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/12/作用域绑定/" class="article-date">
  <time datetime="2019-03-12T03:48:15.000Z" itemprop="datePublished">2019-03-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/12/作用域绑定/">作用域绑定</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="一、作用域绑定"><a href="#一、作用域绑定" class="headerlink" title="一、作用域绑定"></a>一、作用域绑定</h4><p>先看下面的例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">"afei"</span>;</span><br><span class="line"><span class="keyword">var</span> age=<span class="string">"28"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A=&#123;</span><br><span class="line">    name:<span class="string">"alan"</span>,</span><br><span class="line">    A_age:<span class="keyword">this</span>.age,</span><br><span class="line">    getInfo:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">"的年龄是"</span>+<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A.getInfo();<span class="comment">//alan的年龄是undefined</span></span><br></pre></td></tr></table></figure>
<p>这就是作用域改变的例子，在getInfo中的this指向A，而A中没有age属性。</p>
<p>再看下一个例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">"afei"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line">B();<span class="comment">//afei</span></span><br></pre></td></tr></table></figure>
<p>这时的this指向的是全局变量window。</p>
<p>那么如何能改变this指向的作用域呢，传统的方式有bind、apply、call。应用如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name=<span class="string">"afei"</span>;</span><br><span class="line"><span class="keyword">var</span> age=<span class="string">"28"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Test=&#123;</span><br><span class="line">    name:<span class="string">"alan"</span>,</span><br><span class="line">    A_age:<span class="keyword">this</span>.age,</span><br><span class="line">    getInfo:<span class="function"><span class="keyword">function</span>(<span class="params">from,to</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">"的年龄是"</span>+<span class="keyword">this</span>.age+<span class="string">"来自"</span>+<span class="keyword">from</span>+<span class="string">"去往"</span>+to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> A=&#123;</span><br><span class="line">    name:<span class="string">"A"</span>,</span><br><span class="line">    age:<span class="number">11</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> B=&#123;</span><br><span class="line">    name:<span class="string">"B"</span>,</span><br><span class="line">    age:<span class="number">22</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Test.getInfo.call(A,<span class="string">"河南"</span>,<span class="string">"浙江"</span>);<span class="comment">//A的年龄是11来自河南去往浙江</span></span><br><span class="line">Test.getInfo.call(<span class="keyword">this</span>,<span class="string">"河南"</span>,<span class="string">"浙江"</span>);<span class="comment">//afei的年龄是28来自河南去往浙江</span></span><br><span class="line">Test.getInfo.apply(A,[<span class="string">"河南"</span>,<span class="string">"浙江"</span>]);<span class="comment">//B的年龄是22来自河南去往浙江</span></span><br><span class="line">Test.getInfo.bind(A,<span class="string">"河南"</span>,<span class="string">"浙江"</span>)();<span class="comment">//A的年龄是11来自河南去往浙江</span></span><br></pre></td></tr></table></figure>
<p>简单可知：</p>
<ul>
<li>call、bind、apply接受第一个参数就是this指向的上下文</li>
<li>call的接收的原始参数不变，apply接收的原始参数以数组形式传递</li>
<li>bind处理返回的是函数外其余的与call一样</li>
<li>bind返回的是函数，还需要执行</li>
</ul>
<p>还有一种不需要局部绑定this的方法，那就是使用箭头函数</p>
<h4 id="二、箭头（arros）函数"><a href="#二、箭头（arros）函数" class="headerlink" title="二、箭头（arros）函数"></a>二、箭头（arros）函数</h4><h5 id="2-1-语法更简洁"><a href="#2-1-语法更简洁" class="headerlink" title="2.1 语法更简洁"></a>2.1 语法更简洁</h5><p>常规语法定义函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg1</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg1*<span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用箭头函数则只需要一行代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> func=<span class="function">(<span class="params">args</span>)=&gt;</span>args*<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<h5 id="2-2-箭头函数语法"><a href="#2-2-箭头函数语法" class="headerlink" title="2.2 箭头函数语法"></a>2.2 箭头函数语法</h5><p>箭头函数的语法如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(parameters)=&gt;&#123;statements&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有参数则可以直接写成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()=&gt;&#123;statements&#125;</span><br></pre></td></tr></table></figure>
<p>如果只有一个参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parameter=&gt;&#123;statements&#125;</span><br></pre></td></tr></table></figure>
<p>如果返回值仅仅是一个表达式(expression)，可以省略大括号</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parameter=&gt;expression</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">parameter</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> expression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-与this的关系"><a href="#2-3-与this的关系" class="headerlink" title="2.3 与this的关系"></a>2.3 与this的关系</h5><p>箭头函数不会绑定this，即箭头函数不会改变this的本来绑定</p>
<p>例如，想再函数内部实现递增效果，需要有this的局部绑定,不然的话setInterval调用中的this就会绑定给全局变量，从而不能得到正确的count。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CounterTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> that=<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.timer=setInterval(<span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        that.count++;</span><br><span class="line">        <span class="built_in">console</span>.log(that.count);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行new CounterTest()，就会一直执行累加计算</span></span><br><span class="line"><span class="comment">//如果不绑定this，会打印Nan</span></span><br></pre></td></tr></table></figure>
<p>如果不要局部绑定，不用call、apply、bind等方式，还有什么方法呢，就是箭头函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CounterTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.timer=setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count++;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.count);</span><br><span class="line">    &#125;,<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，CounterTest构造函数绑定的this会被保留，在setInterval函数中的this依然是CounterTest的作用域。</p>
<p>参考：<a href="http://www.cnblogs.com/fundebug/p/6904753.html" target="_blank" rel="noopener"></a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/12/作用域绑定/" data-id="ck8iwvpzh0024nso1e2jz23q0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-闭包" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/28/闭包/" class="article-date">
  <time datetime="2019-01-28T00:30:47.000Z" itemprop="datePublished">2019-01-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/28/闭包/">闭包</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><h4 id="一、什么是闭包"><a href="#一、什么是闭包" class="headerlink" title="一、什么是闭包"></a>一、什么是闭包</h4><p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的常用方式就是在一个函数内部创建另一个函数。 </p>
<p>首先来对比一下下面的代码，理解一下闭包</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp=<span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的函数inner对temp的引用是词法作用域的查找规则，这些规则只是闭包的一部分</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp=<span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">arg1</span>)</span>&#123;</span><br><span class="line">        temp--;</span><br><span class="line">        <span class="keyword">if</span>(arg1&lt;temp)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test=outer();</span><br><span class="line">test(<span class="number">8</span>);<span class="comment">//0</span></span><br><span class="line">test(<span class="number">8</span>);<span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面的函数inner的词法作用域能够访问outer内部的作用域，然后将inner()函数本身当作一个值类型进行传递。在outer()执行后，其返回值赋值给test并调用test(),实际上只是通过不同的标识符引用调用了内部的函数inner()</span></span><br></pre></td></tr></table></figure>
<p>一个普通函数outer()，通常会期待在outer()执行后，整个内部作用域都被销毁，因为引擎右垃圾回收器来释放不再使用的内存空间。outer()的内容不会再被使用，所以很自然的会考虑将其回收。</p>
<p><strong>而闭包的神奇之处就是可以阻止这件事情的发生，实际上outer内部作用域依然被引用着，因此没有被回收。是谁在 引用呢，就是inner本身。inner拥有涵盖outer内部作用域的闭包，使得该作用域一直存活，inner的这个引用就是闭包。</strong></p>
<p>由于闭包会携带包含它的函数的作用域，因此会比其它函数占用更多的内存。过度使用闭包可能会导致内存占用过多，我们建议只在绝对必要的时刻载考虑使用闭包</p>
<h4 id="二、闭包与变量"><a href="#二、闭包与变量" class="headerlink" title="二、闭包与变量"></a>二、闭包与变量</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result=<span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        result[i]=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test=createFunction();</span><br><span class="line">test[<span class="number">0</span>]();<span class="comment">//10</span></span><br><span class="line">test[<span class="number">1</span>]();<span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<h4 id="三、函数的类型"><a href="#三、函数的类型" class="headerlink" title="三、函数的类型"></a>三、函数的类型</h4><p>创建函数的几种方式</p>
<ol>
<li><p>声明函数 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匿名函数表达式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn1=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">getFunctionName(fn1).length;<span class="comment">//这种方式创建的函数为匿名函数，没有函数name</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：在对象内定义函数如var o={ fn : function (){…} }，也属于函数表达式</strong></p>
</li>
<li><p>具名函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn2=<span class="function"><span class="keyword">function</span> <span class="title">XXX</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：具名函数表达式的函数名只能在创建函数内部使用</strong></p>
</li>
<li><p>Function构造函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以给 Function 构造函数传一个函数字符串，返回包含这个字符串命令的函数，此种方法创建的是匿名函数。</span></span><br><span class="line"><span class="built_in">Function</span>(<span class="string">"alert(1)"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>自执行函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//让匿名函数自执行</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">1</span>);&#125;)();</span><br></pre></td></tr></table></figure>
</li>
<li><p>其它方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>\setTimeout\setInterval</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="四、注意"><a href="#四、注意" class="headerlink" title="四、注意"></a>四、注意</h3><ol>
<li>全局函数中的this等于window</li>
<li>当函数被某个对象的方法调用时，this等于哪个对象</li>
<li>匿名函数的执行环境具有全局性，this通常指向window</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/28/闭包/" data-id="ck8iwvpzk0029nso1alrenc0k" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GIS/">GIS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Gradle/">Gradle</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/">Markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/">SpringBoot</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebAssembly/">WebAssembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/docker/">docker</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sublime/">sublime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/tomcat/">tomcat</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webgl/">webgl</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/GIS/" style="font-size: 11.67px;">GIS</a> <a href="/tags/Gradle/" style="font-size: 10px;">Gradle</a> <a href="/tags/JavaScript/" style="font-size: 16.67px;">JavaScript</a> <a href="/tags/Markdown/" style="font-size: 10px;">Markdown</a> <a href="/tags/React/" style="font-size: 18.33px;">React</a> <a href="/tags/SpringBoot/" style="font-size: 11.67px;">SpringBoot</a> <a href="/tags/WebAssembly/" style="font-size: 10px;">WebAssembly</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/java/" style="font-size: 13.33px;">java</a> <a href="/tags/linux/" style="font-size: 11.67px;">linux</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/sublime/" style="font-size: 10px;">sublime</a> <a href="/tags/tomcat/" style="font-size: 11.67px;">tomcat</a> <a href="/tags/webgl/" style="font-size: 15px;">webgl</a> <a href="/tags/webpack/" style="font-size: 10px;">webpack</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/02/react-router-dom入门到深入/">react-router-dom入门到深入</a>
          </li>
        
          <li>
            <a href="/2020/04/02/React高阶组件笔记/">React高阶组件笔记</a>
          </li>
        
          <li>
            <a href="/2020/01/09/js中的EventLoop/">js中的EventLoop</a>
          </li>
        
          <li>
            <a href="/2020/01/07/WebAssembly初体验/">WebAssembly初体验</a>
          </li>
        
          <li>
            <a href="/2019/12/24/webgl2基础/">webgl2基础</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 杨亚辉<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>